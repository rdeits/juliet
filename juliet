#!/usr/bin/env julia
import Base.LibGit2
lg = Base.LibGit2

type DevRequirement <: Pkg.Reqs.Line
    url::String
    ref::String
    name::String
end

DevRequirement(url::AbstractString, ref::AbstractString) = DevRequirement(url, ref, extract_pkg_name(url))

function DevRequirement(line::AbstractString)
    m = match(r"([^\s]+)\s+([^\s]+)", line)
    if m == nothing
        throw(PkgError("This line looks like a dev requirement, but I can't parse it: $(line)"))
    end
    DevRequirement(m.captures[1], m.captures[2])
end

function checkout(req::DevRequirement)
    # Returns true if HEAD was moved, false otherwise
    repo = lg.GitRepo(Pkg.dir(req.name))
    juliet_remote_name = replace("juliet_$(req.url)", r"[:%/.@]", "_")

    existing_remotes = lg.remotes(repo)
    if juliet_remote_name in existing_remotes
        lg.set_remote_url(repo, req.url, remote=juliet_remote_name)
    else
        lg.GitRemote(repo, juliet_remote_name, req.url)
    end
    current_sha = lg.head_oid(repo)
    requested_sha = lg.revparseid(repo, req.ref)
    if requested_sha == lg.Oid()
        lg.fetch(repo, remote=juliet_remote_name)
    end
    requested_sha = lg.revparseid(repo, req.ref)
    if requested_sha == lg.Oid()
        error("Could not find the requested revision. Package: $(path(repo)), remote: $(juliet_remote_name), ref: $(req.ref)")
    end
    if current_sha != requested_sha
        lg.checkout!(repo, req.ref)
        cd(Pkg.dir()) do
            if !Base.Pkg.Entry.edit(Pkg.Reqs.add, req.name)
                isempty(Pkg.Reqs.parse("$(req.name)/REQUIRE")) && return
                Pkg.resolve()
            end
        end
        return true
    else
        return false
    end
end

function clone(req::DevRequirement)
    cd(Pkg.dir()) do
        pkg = req.name
        info("Cloning $pkg from $(req.url)")
        ispath(pkg) && throw(PkgError("$(req.name) already exists"))
        try
            lg.with(lg.clone(req.url, pkg)) do repo
                lg.set_remote_url(repo, req.url)
                lg.checkout!(repo, req.ref)
            end
        catch err
            isdir(pkg) && Base.rm(pkg, recursive=true)
            rethrow(err)
        end
        if !Base.Pkg.Entry.edit(Pkg.Reqs.add, req.name)
            isempty(Pkg.Reqs.parse("$pkg/REQUIRE")) && return
            Pkg.resolve()
        end
    end
end


function clone_or_checkout(req::DevRequirement)
    new_clone = false
    if !isdir(Pkg.dir(req.name))
        clone(req)
        Pkg.build(req.name)
    else
        head_moved = checkout(req)
        if head_moved
            Pkg.build(req.name)
        end
    end
end


function extract_pkg_name(url::AbstractString)
    m = match(r"(?:^|[/\\])(\w+?)(?:\.jl)?(?:\.git)?$", url)
    if m == nothing
        throw(PkgError("can't determine package name from URL: $url"))
    else
        return m.captures[1]
    end
end

function parse_dev_requirements(dev_file)
    reqs = Vector{Pkg.Reqs.Line}()
    for line in split(open(readstring, dev_file), '\n')
        cleaned_line = strip(replace(line, r"#.*", ""))
        if length(cleaned_line) == 0
            continue
        end
        url_match = match(r"^(https://|git@|git://|http://)", cleaned_line)
        if url_match != nothing
            push!(reqs, DevRequirement(cleaned_line))
        else
            push!(reqs, Pkg.Reqs.Requirement(line))
        end
    end
    reqs
end

function install(require_file="REQUIRE.dev")
    if !isdir(joinpath(Pkg.dir(), "METADATA"))
        mkpath(Pkg.dir())
        Pkg.init()
    end

    lines = parse_dev_requirements(require_file)

    reqs = open(Pkg.Reqs.parse, joinpath(Pkg.dir(), "REQUIRE"))

    for line in lines
        if isa(line, Base.Pkg.Reqs.Requirement)
            if !isempty(line.system)
                applies = false
                @static if is_windows()
                    applies |=  ("windows"  in line.system)
                    applies &= !("!windows" in line.system)
                end
                @static if is_unix()
                    applies |=  ("unix"     in line.system)
                    applies &= !("!unix"    in line.system)
                end
                @static if is_apple()
                    applies |=  ("osx"      in line.system)
                    applies &= !("!osx"     in line.system)
                end
                @static if is_linux()
                    applies |=  ("linux"    in line.system)
                    applies &= !("!linux"   in line.system)
                end
                applies || continue
            end
            reqs[line.package] = haskey(reqs, line.package) ?
                intersect(reqs[line.package], line.versions) : line.versions
        else
            clone_or_checkout(line)
        end
    end

    open(joinpath(Pkg.dir(), "REQUIRE"), "w") do f
        Pkg.Reqs.write(f, reqs)
    end
    Pkg.resolve()
end

function print_usage()
    println("""
usage: juliet [-h] install [require_dev_file]

Arguments:
  require_dev_file [default: REQUIRE.dev] development requirements file

Options:
  -h, --help       display this message and exit


`Juliet install` will attempt to install all of the registered and unregistered
packages listed in your require_dev_file. The require_dev_file expands the
standard REQUIRE file syntax to allow packages to be specified by their git URL
and ref (which can be a commit SHA, branch name, or tag name). You can mix and
match standard REQUIRE entries with these additional entries. For example:

# file: REQUIRE.dev:

IJulia
https://github.com/rdeits/DrakeVisualizer.jl.git 0766c8c93
https://github.com/JuliaLang/Reactive.jl.git v0.3.3
Interact 0.3.1

Running `juliet install` with the above file should result in the listed
packages and all of their dependencies being installed. By default, they will be
installed globally, just as if you'd done `Pkg.add` or `Pkg.clone` yourself. To
install the packages to another location instead, just set the JULIA_PKGDIR
environment variable before running `juliet install`.

""")
end

function main()
    if any(x -> x == "-h" || x == "--help", ARGS)
        print_usage()
        return
    elseif length(ARGS) > 2 || length(ARGS) == 0
        print_usage()
        return
    else
        if lowercase(ARGS[1]) == "install"
            command_args = ARGS[2:end]
            if length(command_args) > 0
                require_dev_file = command_args[1]
            else
                require_dev_file = "REQUIRE.dev"
            end
            install(require_dev_file)
        else
            print_usage()
        end
        return
    end
end

main()
