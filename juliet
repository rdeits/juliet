#!/usr/bin/env julia

type DevRequirement <: Pkg.Reqs.Line
    url::ASCIIString
    ref::ASCIIString
    name::ASCIIString
end

DevRequirement(url::AbstractString, ref::AbstractString) = DevRequirement(url, ref, extract_pkg_name(url))

function DevRequirement(line::AbstractString)
    m = match(r"([^\s]+)\s+([^\s]+)", line)
    if m == nothing
        throw(PkgError("This line looks like a dev requirement, but I can't parse it: $(line)"))
    end
    DevRequirement(m.captures[1], m.captures[2])
end


get_sha(object) = strip(readall(`git rev-list -1 $(object)`))

function checkout(req::DevRequirement)
    # Returns true if HEAD was moved, false otherwise
    cd(Pkg.dir(req.name)) do
        run(`git remote set-url origin $(req.url)`)
        run(`git fetch origin`)
        current_sha = get_sha("HEAD")
        requested_sha = get_sha(req.ref)
        if current_sha != requested_sha
            run(`git checkout $(req.ref)`)
            return true
        else
            return false
        end
    end
end

function clone_or_checkout(req::DevRequirement)
    new_clone = false
    if !isdir(Pkg.dir(req.name))
        Pkg.clone(req.url)
        new_clone = true
    end
    head_moved = checkout(req)
    if new_clone || head_moved
        Pkg.build(req.name)
    end
end


function extract_pkg_name(url::AbstractString)
    m = match(r"(?:^|[/\\])(\w+?)(?:\.jl)?(?:\.git)?$", url)
    if m == nothing
        throw(PkgError("can't determine package name from URL: $url"))
    else
        return m.captures[1]
    end
end

function parse_dev_requirements(dev_file)
    reqs = Vector{Pkg.Reqs.Line}()
    for line in split(open(readall, dev_file), '\n')
        cleaned_line = strip(replace(line, r"#.*", ""))
        if length(cleaned_line) == 0
            continue
        end
        url_match = match(r"^(https://|git@|git://|http://)", cleaned_line)
        if url_match != nothing
            push!(reqs, DevRequirement(cleaned_line))
        else
            push!(reqs, Pkg.Reqs.Requirement(line))
        end
    end
    reqs
end

function handle(req::Union{Pkg.Reqs.Requirement, Pkg.Reqs.Comment}, req_file::IO)
    Pkg.Reqs.write(req_file, Pkg.Reqs.Line[req])
end

function handle(req::DevRequirement, req_file::IO)
    clone_or_checkout(req)
end

function install(require_file="REQUIRE.dev")
    if !isdir(Pkg.dir())
        mkpath(Pkg.dir())
        Pkg.init()
    end

    requirements = parse_dev_requirements(require_file)
    open(joinpath(Pkg.dir(), "REQUIRE"), "w") do f
        map(req -> handle(req, f), requirements)
    end
    Pkg.resolve()
end

function print_usage()
    println("""
usage: juliet [-h] install [require_dev_file]

Arguments:
  require_dev_file [default: REQUIRE.dev] development requirements file

Options:
  -h, --help       display this message and exit


`Juliet install` will attempt to install all of the registered and unregistered
packages listed in your require_dev_file. The require_dev_file expands the
standard REQUIRE file syntax to allow packages to be specified by their git URL
and ref (which can be a commit SHA, branch name, or tag name). You can mix and
match standard REQUIRE entries with these additional entries. For example:

# file: REQUIRE.dev:

IJulia
https://github.com/rdeits/DrakeVisualizer.jl.git 0766c8c93
https://github.com/JuliaLang/Reactive.jl.git v0.3.3
Interact 0.3.1

Running `juliet install` with the above file should result in the listed
packages and all of their dependencies being installed. By default, they will be
installed globally, just as if you'd done `Pkg.add` or `Pkg.clone` yourself. To
install the packages to another location instead, just set the JULIA_PKGDIR
environment variable before running `juliet install`.

""")
end

function main()
    if any(x -> x == "-h" || x == "--help", ARGS)
        print_usage()
        return
    elseif length(ARGS) > 2 || length(ARGS) == 0
        print_usage()
        return
    else
        if lowercase(ARGS[1]) == "install"
            command_args = ARGS[2:end]
            if length(command_args) > 0
                require_dev_file = command_args[1]
            else
                require_dev_file = "REQUIRE.dev"
            end
            install(require_dev_file)
        else
            print_usage()
        end
        return
    end
end

main()
